/**
* \file socket.hpp
* \author kadds (itmyxyf@gmail.com)
* \brief this part includes socket functions: send, recv, accept, connect, bind.
* \version 0.1
* \date 2020-03-13
*
* @copyright Copyright (c) 2020.
This file is part of P2P-Live.

P2P-Live is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

P2P-Live is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with P2P-Live. If not, see <http: //www.gnu.org/licenses/>.
*
*/
#pragma once
#include "co.hpp"
#include "event.hpp"
#include "execute_context.hpp"
#include "net.hpp"
#include "socket_addr.hpp"
#include "socket_buffer.hpp"
#include <queue>
#ifdef OS_WINDOWS
#include "iocp.hpp"
#endif

namespace net
{
///\note socket_t is generated by 'new_tcp_socket', 'new_udp_socket'
///\note socket_t is destoried by 'delete_socket' which also close socketfd
class socket_t : public execute_context_t, event_handler_t
{
  protected:
    handle_t fd;
    socket_addr_t local;
    socket_addr_t remote;
    bool is_connection_closed;

    friend co::async_result_t<io_result> connect_to(co::paramter_t &, socket_t *, socket_addr_t);
    friend co::async_result_t<socket_t *> accept_from(co::paramter_t &, socket_t *in);
    friend class event_loop_t;

  public:
    socket_t(int fd);
    ~socket_t();
    socket_t(const socket_t &) = delete;
    socket_t &operator=(const socket_t &) = delete;

    virtual co::async_result_t<io_result> awrite(co::paramter_t &, socket_buffer_t &buffer) = 0;
    virtual co::async_result_t<io_result> aread(co::paramter_t &, socket_buffer_t &buffer) = 0;

    virtual co::async_result_t<io_result> awrite_to(co::paramter_t &, socket_buffer_t &buffer,
                                                    socket_addr_t target) = 0;
    virtual co::async_result_t<io_result> aread_from(co::paramter_t &, socket_buffer_t &buffer,
                                                     socket_addr_t &target) = 0;

    socket_addr_t local_addr();
    socket_addr_t remote_addr();

    void on_event(event_context_t &context, event_type_t type) override;

    void add_event(event_type_t type);
    void remove_event(event_type_t type);

    handle_t get_raw_handle() const { return fd; }

    bool is_connection_alive() const { return !is_connection_closed; }

    void bind_context(event_context_t &context);
    void unbind_context();
};

class bsd_socket_t : public socket_t
{
  public:
    using socket_t::socket_t;
    co::async_result_t<io_result> awrite(co::paramter_t &, socket_buffer_t &buffer) override;
    co::async_result_t<io_result> aread(co::paramter_t &, socket_buffer_t &buffer) override;

    co::async_result_t<io_result> awrite_to(co::paramter_t &, socket_buffer_t &buffer, socket_addr_t target) override;
    co::async_result_t<io_result> aread_from(co::paramter_t &, socket_buffer_t &buffer, socket_addr_t &target) override;
};

class iocp_socket_t : public socket_t
{
  public:
    using socket_t::socket_t;
    co::async_result_t<io_result> awrite(co::paramter_t &, socket_buffer_t &buffer) override;
    co::async_result_t<io_result> aread(co::paramter_t &, socket_buffer_t &buffer) override;

    co::async_result_t<io_result> awrite_to(co::paramter_t &, socket_buffer_t &buffer, socket_addr_t target) override;
    co::async_result_t<io_result> aread_from(co::paramter_t &, socket_buffer_t &buffer, socket_addr_t &target) override;
};

co::async_result_t<io_result> socket_awrite(co::paramter_t &param, socket_t *socket, socket_buffer_t &buffer);
co::async_result_t<io_result> socket_aread(co::paramter_t &param, socket_t *socket, socket_buffer_t &buffer);

co::async_result_t<io_result> socket_awrite_to(co::paramter_t &param, socket_t *socket, socket_buffer_t &buffer,
                                               socket_addr_t target);
co::async_result_t<io_result> socket_aread_from(co::paramter_t &param, socket_t *socket, socket_buffer_t &buffer,
                                                socket_addr_t &target);

/// ----------- socket functions ----------------------

socket_t *new_tcp_socket();
socket_t *new_udp_socket();

socket_t *reuse_addr_socket(socket_t *socket, bool reuse);
socket_t *reuse_port_socket(socket_t *socket, bool reuse);

co::async_result_t<io_result> connect_to(co::paramter_t &param, socket_t *socket, socket_addr_t socket_to_addr);
co::async_result_t<io_result> connect_udp(co::paramter_t &param, socket_t *socket, socket_addr_t socket_to_addr);

socket_t *bind_at(socket_t *socket, socket_addr_t socket_to_addr);
socket_t *listen_from(socket_t *socket, int max_wait_client);
co::async_result_t<socket_t *> accept_from(co::paramter_t &param, socket_t *in);
void close_socket(socket_t *socket);

socket_t *set_socket_send_buffer_size(socket_t *socket, int size);
socket_t *set_socket_recv_buffer_size(socket_t *socket, int size);
int get_socket_send_buffer_size(socket_t *socket);
int get_socket_recv_buffer_size(socket_t *socket);

/// get local ip address
socket_addr_t get_ip(socket_t *socket);

} // namespace net
